Вывод по сравнению двух garbage collector: Serial Collector vs G1.
Проверял работу gc добавлением и удалением Integer в List при выделение 512мб (до oom) 
    и 1024Мб (в течение 10 минут).
    
                	    gc1	    SerialGC    gc1	        SerialGC
				
выделение ОЗУ   	    512Mb	512Mb	    1024Mb 	    1024Mb
				
ООМ сек	                433	    363	        600	        600
Кол-во сборок	        
    young               3630    1010        2311        1311
    sum young ms        128432  268044      147242      487903
    average young ms    35,38   265,39      63,71       372,16
    
    concurrent          421     592         191         437
    sum conc. ms        109247  260395      75638       343753
    average conc. ms    259,49  439,85      396,01      786,62
    			
средняя нагрузка 
    по CPU	            60-70%	11-12%	    60-70%	    11-12%
средняя нагрузка 
    по CPU (gc)	        6-8%	10-11%	    6-8%	    10-11%
				
ОЗУ среднее 
    использование 	    -       -   	     ~700мб     ~500мб
   

в результате проведенных сравнений выяснил, что в целом время лага при young и old при использование
gc1 меньше, чем в SerialGC. Даже с учетом того, что колво сборок при использование gc1 больше, но 
затрачивание время, как в целом, так и в среднем меньше. Однако, при проверки visualVM удалось обнаружить,
что при работе приложения с gc1, значительно используется процессор, по сравнению с SerialGC, причем затраты 
на работу самого gc, в gc1 ниже. 
По всем показателям лучше использовать gc1.
Но, при наличие достаточного кол-во оперативной памяти, в сравнение 1024Мб, и при выводе значение count 
(параметра, который отвечает за то, сколько Объектов Integer будет добавлено или убрано) при проверки в 10 минут, 
SerialGC смог достичь значения в 21млн, в то время как gc1 смог достичь только 19млн. То есть при необходимости 
быстро сделать работу, и в случае, когда время лага не важно, лучше использовать SerialGC.
(к сожалению, текущая моя машина не позволяет довести сравнение до конца, к примеру выдать >8гб ОЗУ и дождаться 
когда весь List заполнится и посмотреть кто быстрее справится с этим, но есть предположение что SerialGC).